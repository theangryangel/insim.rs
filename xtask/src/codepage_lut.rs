use std::{collections::BTreeSet, fmt::Write, fs, path::PathBuf};

use encoding_rs::Encoding;

const MAX_UNICODE: u32 = 0x10FFFF;
// XXX: 9 is left off this by design to prevent double checking LATIN1
const CODEPAGES: [(char, &Encoding); 10] = [
    ('L', encoding_rs::WINDOWS_1252),
    ('G', encoding_rs::ISO_8859_7),
    ('C', encoding_rs::WINDOWS_1251),
    ('E', encoding_rs::ISO_8859_2),
    ('T', encoding_rs::WINDOWS_1254),
    ('B', encoding_rs::ISO_8859_13),
    ('J', encoding_rs::SHIFT_JIS),
    ('H', encoding_rs::GBK),
    ('S', encoding_rs::EUC_KR),
    ('K', encoding_rs::BIG5),
];

#[derive(Debug, Clone)]
struct RangeMask {
    start: u32,
    end: u32,
    mask: u16,
}

pub(super) fn run(check: bool) -> Result<(), Box<dyn std::error::Error>> {
    let ranges = build_disjoint_ranges();
    let generated = emit_rust(&ranges);
    let output_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .ok_or("No parent dir")?
        .join("insim_core/src/string/codepages_lut.rs");

    if check {
        let existing = fs::read_to_string(&output_path)?;
        if existing != generated {
            return Err(format!("generated LUT differs from {}", output_path.display()).into());
        }
    } else {
        fs::write(&output_path, generated)?;
    }

    Ok(())
}

fn codepage_mask_for_char(ch: char) -> u16 {
    let mut buf = [0u8; 4];
    let s = ch.encode_utf8(&mut buf);

    CODEPAGES.iter().enumerate().fold(0, |mask, (i, (_, enc))| {
        let (_, _, had_errors) = enc.encode(s);
        if !had_errors { mask | (1 << i) } else { mask }
    })
}

fn build_disjoint_ranges() -> Vec<RangeMask> {
    let mut ranges: Vec<RangeMask> = Vec::new();

    for cp in 0..=MAX_UNICODE {
        let Some(ch) = char::from_u32(cp) else {
            continue;
        };
        let mask = codepage_mask_for_char(ch);

        if let Some(last) = ranges.last_mut() {
            if last.mask == mask && last.end + 1 == cp {
                last.end = cp;
                continue;
            }
        }

        ranges.push(RangeMask {
            start: cp,
            end: cp,
            mask,
        });
    }
    ranges
}

fn emit_rust(ranges: &[RangeMask]) -> String {
    let mut out = String::new();
    let unique_masks: Vec<u16> = ranges
        .iter()
        .map(|r| r.mask)
        .collect::<BTreeSet<_>>()
        .into_iter()
        .collect();

    writeln!(out, "// Generated by xtask codepage-lut").unwrap();
    writeln!(out, "static CODEPAGE_MARKER_SETS: &[&[char]] = &[").unwrap();

    for &mask in &unique_masks {
        let markers: Vec<_> = CODEPAGES
            .iter()
            .enumerate()
            .filter_map(|(i, (m, _))| {
                if mask & (1 << i) != 0 {
                    Some(format!("'{m}'"))
                } else {
                    None
                }
            })
            .collect();
        writeln!(out, "    &[{}],", markers.join(", ")).unwrap();
    }
    writeln!(out, "];\n").unwrap();

    writeln!(out, "static CODEPAGE_RANGES: &[(u32, u32, usize)] = &[").unwrap();
    for r in ranges {
        let idx = unique_masks.binary_search(&r.mask).unwrap();
        writeln!(out, "    ({}, {}, {}),", r.start, r.end, idx).unwrap();
    }
    writeln!(out, "];").unwrap();

    out.push_str(
        "
pub(super) fn lookup(ch: char) -> &'static [char] {
    let cp = ch as u32;
    CODEPAGE_RANGES
        .binary_search_by(|&(start, end, _)| {
            if cp < start {
                std::cmp::Ordering::Greater
            } else if cp > end {
                std::cmp::Ordering::Less
            } else {
                std::cmp::Ordering::Equal
            }
        })
        .map(|idx| CODEPAGE_MARKER_SETS[CODEPAGE_RANGES[idx].2])
        .unwrap_or_default()
}
",
    );
    out
}
