<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title></title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body></body>

  <script
    async
    src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
  ></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { TrackballControls } from "three/addons/controls/TrackballControls.js";

    const fitCameraToCenteredObject = function (
      camera,
      object,
      offset,
      orbitControls
    ) {
      const boundingBox = new THREE.Box3();
      boundingBox.setFromObject(object);

      var middle = new THREE.Vector3();
      var size = new THREE.Vector3();
      boundingBox.getSize(size);
      boundingBox.getCenter(middle);

      // figure out how to fit the box in the view:
      // 1. figure out horizontal FOV (on non-1.0 aspects)
      // 2. figure out distance from the object in X and Y planes
      // 3. select the max distance (to fit both sides in)
      //
      // The reason is as follows:
      //
      // Imagine a bounding box (BB) is centered at (0,0,0).
      // Camera has vertical FOV (camera.fov) and horizontal FOV
      // (camera.fov scaled by aspect, see fovh below)
      //
      // Therefore if you want to put the entire object into the field of view,
      // you have to compute the distance as: z/2 (half of Z size of the BB
      // protruding towards us) plus for both X and Y size of BB you have to
      // figure out the distance created by the appropriate FOV.
      //
      // The FOV is always a triangle:
      //
      //  (size/2)
      // +--------+
      // |       /
      // |      /
      // |     /
      // | F° /
      // |   /
      // |  /
      // | /
      // |/
      //
      // F° is half of respective FOV, so to compute the distance (the length
      // of the straight line) one has to: `size/2 / Math.tan(F)`.
      //
      // FTR, from https://threejs.org/docs/#api/en/cameras/PerspectiveCamera
      // the camera.fov is the vertical FOV.

      const fov = camera.fov * (Math.PI / 180);
      const fovh = 2 * Math.atan(Math.tan(fov / 2) * camera.aspect);
      let dx = size.z / 2 + Math.abs(size.x / 2 / Math.tan(fovh / 2));
      let dy = size.z / 2 + Math.abs(size.y / 2 / Math.tan(fov / 2));
      let cameraZ = Math.max(dx, dy);

      // offset the camera, if desired (to avoid filling the whole canvas)
      if (offset !== undefined && offset !== 0) cameraZ *= offset;

      camera.position.set(0, 0, cameraZ);

      // set the far plane of the camera so that it easily encompasses the whole object
      const minZ = boundingBox.min.z;
      const cameraToFarEdge = minZ < 0 ? -minZ + cameraZ : cameraZ - minZ;

      camera.far = cameraToFarEdge * 3;
      camera.updateProjectionMatrix();

      if (orbitControls !== undefined) {
        // set camera to rotate around the center
        //orbitControls.target = new THREE.Vector3(0, 0, 0);

        orbitControls.target = middle;

        // prevent camera from zooming out far enough to create far plane cutoff
        orbitControls.maxDistance = cameraToFarEdge * 2;
      }
    };

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888, 1);

    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      1,
      5000
    );
    camera.position.set(0, 0, 1000);
    camera.lookAt(0, 0, 0);

    //var controls = new OrbitControls( camera, renderer.domElement );
    var controls = new TrackballControls(camera, renderer.domElement);

    const scene = new THREE.Scene();

    scene.add(new THREE.AmbientLight(0x444444));

    let collections = await fetch("/bl.json")
      .then((res) => res.json())
      .then((res) => res.collection);

    const track = new THREE.Group();

    for (const [idx, collection] of collections.entries()) {
      const points = [];

      for (let i of collection.triangles) {
        const [one, two, three, four] = i;

        points.push(new THREE.Vector3(one[0], one[1], one[2]));
        points.push(new THREE.Vector3(two[0], two[1], two[2]));
        points.push(new THREE.Vector3(three[0], three[1], three[2]));
      }

      let colour = 0x19171c;

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.MeshBasicMaterial({
        color: colour,
        side: THREE.DoubleSide,
      });

      const line = new THREE.Mesh(geometry, material);

      //scene.add( line );

      track.add(line);
    }

    scene.add(track);

    fitCameraToCenteredObject(camera, track, 1.05, controls);

    var h = 5;
    var redCar = new THREE.Mesh(
      new THREE.BoxBufferGeometry(h, h, h),
      new THREE.MeshBasicMaterial({
        color: 0xff0000,
        side: THREE.DoubleSide,
        wireframe: true,
      })
    );
    scene.add(redCar);

    renderer.render(scene, camera);

    let posIndex = 0;

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);

      const duration = 1000;
      const t = (performance.now() % duration) / duration;

      if (t >= 0.75) {
        posIndex += 2;

        if (posIndex >= collections[0].triangles.length) {
          posIndex = 0;
        }
        let redCarPos = collections[0].triangles[posIndex][0];
        redCar.position.set(redCarPos[0], redCarPos[1], redCarPos[2] + 10);
      }
      controls.update();
    }

    animate();
  </script>
</html>
